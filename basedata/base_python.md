# python 基础
>* 运行日志：
>    *  code 0 运行成功，code 1 运行失败
>* **报错**
>    *  SyntaxError 语法错误
>    *  AttributeError 属性错误
>        *  例如元组没有append()			
>* **python 特点**
>    *   大小写敏感
>    *  变量名不能数字开头（字母_数字）
>    *  变量不需要声明，可以直接使用
>    *  以下划线开头的标识符是有特殊意义的。
>        *  以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。
>        *  以双下划线开头的 __foo__ 代表类的私有成员，
>        *  以双下划线开头和结尾的 "__ foo __" 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。
>            *      __file__ 打印此时运行的文件的绝对路径
>    *  Python 允许你同时为多个变量赋值，例如 a=b=c=1 ,或者a,b,c = 1,2,'aaa'
>    *  通常用全部大写的变量名表示常量（但只是代表，也可以改变）
>* **数据类型**
>    *  **数字**
>        *  整数型 - int 
>        *  浮点型 - float 
>        *  复数型 - complex
>            *  complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。
>            *  complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式
>    *  **进制转换**
>        *  10--->2
>            *  bin()
>            *  补齐0
>                *  bin(整数).zfill(8)
>                *  补齐成8位
>        *  2--->10
>            *  int(字符串，2)
>        *  16--->10
>            *  int(字符串，16)
>        *  8--->10
>            *  int(字符串，8)
>        *  10--->16
>            *  hex(字符串)
>        *  10--->8
>            *  oct(字符串)
>    *   **字符串 - String**
>        *  使用 ‘’  ，“ ” ，''' ''' , """ “”“ 来创建
>        *  具有层次结构，比如 变量 b = “我说：'你怎么看 ' ”
>        *  字符串拼接
>            *  使用格式化拼接
>                *  print('%s %s %s' % ('我', '是', '中国人'))     # 我 是 中国人 
>                *  使用format
>                    *  print("{} {} {}".format('我', '是', '中国人'))
>            *  或者join()
>                *  "".join(a1,b1)
>    *   **布尔型 - bool True False**
>    *   **元组 - tuple** 
>        *  内容不可改，
>        *  可以有多种数据类型，
>        *  元素可以重复
>    *   **列表 - list**
>        *  可以有多种数据类型，
>        *  元素可以重复
>    *  **集合 - Sets**
>        *  无序不重复
>            *  可以用来去重
>        *  创建空集合使用: set()
>        *  不能被切片，不能被索引，可以添加，删除
>    *   **字典 - dict**
>        *  字典里的值可以取任何数据类型
>        *  字典里的键必须是唯一的，但值则不必
>        *  字典里存储的是键值对
>    *  python 没有字符类型
>* **元组，列表切片**
>    *  【起点：终点：间隔】
>    *  终点不会被包括
>* **列表** 
>    *  append()追加
>    *  insert(索引，值) 插入
>    *  pop（索引）删除索引处的值
>    *  remove(值)删除某个值
>    *  sort()排序，改变原有数组
>    *  reverse()倒序，改变原有数组
>    *   新数组= sorted(原数组) 升序，不改变原有数组
>* **字典**
>  * {键：值，键：值.....}
>* **运算、逻辑符号**
>    *   <   >  >=  <= != 
>    *  / + - * 
>    *  and or ! 按位与 或 非
>    *  % 取余
>    *  ** 平方
>    *  //取整数 5.0//2.0 =2
>    *  in ， not in 判断值是否在某个集合
>    *  a,b=b,a 两数对换（python独有）
>* **循环**
>    *  while
>        *  所有非0都会被认为是真，包括负数
>    *  for m in range(m)
>        *  range生成元组
>        *  0 ~ m-1
>        *  可以切片[起点，终点，间隔]
>* **分支**
>    *  if() …else:
>    *  if() … elif():…else:
>    *  try: …except 捕捉错误: else:
>* **常用命令：**
>    *  print 自带换行
>        *  print( "mmm",end=' ' ) 以空格结尾，不换行
>* **函数**
>    * Python中定义函数的关键字是def（单词define，定义的意思）。
>    * 函数名自己随意取名，但是必须满足命名规则：
>        *  函数名称全小写，其他情况和变量命名差不多
>        *  单词间的空格以“下划线”替代
>        *  不可以使用Python内置名字（函数、变量等）
>        *  不可以和变量重名
>    * 设计函数时，可以是“有参函数”，也可以是“无参函数”
>    * 函数的定义代码必须要在函数的调用代码的上方，不然调用不到！！！
>    * 我们习惯在一个模块(.py文件)里，把所有设计的函数统一放在最上方管理。
>    * **默认参数**
>        *  在定义形参时赋值
>        *  放在参数最后
>        *  可通过传参赋值
>    * **可变参数**
>        *  格式：* 形参 
>        *  函数内接受到的是一个元组tuple()
>        *  传参方式： 参数1，参数2…..参数n			
>    * **关键字参数**
>        *  格式：**形参
>        *  函数内接受到的是一个字典
>        *  传参方式：键1=值1，键2=值2…键n=值n
>    * **return**
>        *  只要执行了return程序就会跳出
>    * **函数、模块和包**
>        *  函数
>            *  包含功能的代码块
>        *  模块
>            *  包含多个函数的.py文件
>            *  模块的导入from 包名 import 模块名
>        *  包
>            *  包含多个模块文件的目录
>            *  可以包含其他包
>            *  只有包中的py文件可以互相调用
>            *  目录下有“__init__.py”文件
>            *  包的导入 ：import  包名 
>            *  如果同级目录里有包名和模块重名，会优先导入包
>            *  如果包里面有模块名和包的名字相同，导入的时候是从包开始，IDE不会报错，
>                *  但执行的时候会先从本地目录（即包目录下开始），这种情况下本地文件覆盖了包的引用导致报错
>            *  被打开的文件夹中（即同一目录下或者包中）有文件与要导入的包或模块同名，就会产生覆盖，导致import的失败。
>            *  在线安装 
>                *  pip install 包名==版本名（可选）
>            *  本地安装 
>                *  切到要安装的包里面
>                *  python setup.py install
>    * 主函数
>        * main + enter键
>    * 跨模块调用
>        * 导入包：
>            * 在函数名上 alt + 回车

# **面向对象**
>    * **封装，继承，多态**
>    * 类的格式：
>        *  class 类名字（单词首字母大写）:
>        *  def 可选__init__(self,形参列表):#构造方法（构造对象的时候自动被执行）
>        *  规定了===》属性(类的阶段规定属性 没有规定具体的值)
>        *  属性有全局变量的特点===》跨函数也可以使用 self.属性名字1
>        *  def 可选方法名字1(self,形参列表):   需要调用才能被执行 方法执行体1
>        *  def 可选方法名字2(self,形参列表):   需要调用才能被执行方法执行体2
>    * self为了能在类中相互调用
>    * __init__()构造方法
>        *  所有类都具有
>        *  类实例化时（创建对象的时候）执行
>        *  self可以改名，所以self不是关键字
>    * **继承**
>        *  class 子类名（父类）
>        *  子类可以使用父类的方法和属性
>        *  重写父类方法
>            * super().父类的代名词
>            * 子类新增属性，余下继承父类

# **文件读写**
>    * 自动化代码中读取数据用
>    * **读文件**
>        * f = open(file_name, mode='r', encoding='utf-8') 打开文件
>            *  file_name 文件路径，尽量用相对路径，如：./abc.txt
>            *  'r' 代表read
>            *  encoding 代表编码格式
>        * txt = f.read()  读全文，文本输出
>          * f.close() 结束关闭文件
>        * with open() as f  的写法，最大的好处就是不用手写close()方法，可以自动关闭
>          * readline()读取一行
>              *  文本输出
>              *  reaadline(n) 读取前n个字节
>          * readlines()读取所有行，
>              *  在一次打开文件的行为中，分多次读取的话，之前被读取过得行不会再被读取
>              *  列表输出，一行就是一项
>    * **追加文件**
>        *      with open(file_name, mode='a', encoding='utf-8') as f:
>        *      f.write('\nGo语言')
>        *  ‘a’代表append添加
>        *  'a+'可读可追加
>        *  content = f.readlines()
>        *  with open() as f的写法，最大的好处就是不用手写close()方法，可以自动关闭
>        *  以一个列表的形式读取文件内所有行的内容，一行就是一个列表内的元素
>        *  readlines(2)的意思是读取前2行文件内容，以此类推；如果不填写，代表读取所有行的内容
>    * **写文件**
>        *  with open(file_name, mode='w', encoding='utf-8') as f
>        *  ‘w ’ 写文件，会把文件的内容删除
>        *  ‘w+’可读可写
>        *  文件不存在时会创建文件并写入
>    * **创建文件**
>        * ‘x’ 要求创建的文件不存在，文件存在会报错
>          * 详细说明：

> * <img src="/img/file.png"/>
> * <img src="/img/os.png"/>

			
			
			




# unittest测试框架
>* **unittest**(其他测试框架还有pytest,doctest,nose)
>  * **基类组成：**
>    * test fixture 测试固件
>        * 用于测试开始前的准备和结束后的清理工作
>    * text case 测试用例
>        * 用来编写测试用例，所以一个test开头的函数就是一个测试用例
>    * test suite 测试套件
>        * 用来组装测试用例
>    * test runner 测试运行器
>        * 用来执行测试用例和生成报告
>  * **格式：**
>      * class  测试的类名(继承unittest.TestCase):
>      * 可选 def  setUp(self)：   #U大写
>        * 测试用例的准备工作，只有当每一条测试用例执行之前都会被调用
>      * 可选 def  tearDown(self)：   #D大写
>        * 测试用例的结束工作，只有当每一条测试用例执行后都会被调用
>        * 测试用例----必须是以test开头的函数
>      * def  test_名字1(self):
>        * 思路： 预期结果 和实际结果 然后使用断言（比较预期和实际结果的） 
>      * def  test_名字2(self):
>        * 思路： 预期结果 和实际结果 然后使用断言（比较预期和实际结果的）
>      * def  test_名字3(self):
>        * 思路： 预期结果 和实际结果 然后使用断言（比较预期和实际结果的） 
>        * 。。。。。。
>        * 用途：编写规范的测试用例，组织测试用例，生成测试结果
>        * -> 标注函数返回值类型
>  * **断言方法：**
>      * assertEqual(预期结果，实际结果，错误说明) 结果相等通过
>      * assertNotEqual (预期结果，实际结果，错误说明) 结果不相等通过
>      * assertTrue(实际结果) 结果为True 通过
>      * assertFalse(实际结果，错误说明) 结果为False 通过 
>      * assertIn(a，b，错误说明)) a在b中 通过
>      * assertNotIn(a，b，错误说明)) a不在b中 通过
>      * 终端执行时，输出F代表一个用例失败； . 代表一个用例成功；输出E代表类或者类方法有错误（使用方式不对，或者定义有误）
>  * **测试用例的执行顺序**
>      * **默认顺序：按ASCII码的顺序**
>          *  使用unittest.main()方法
>          *  0-9 A-Z 下划线 _  a-z
>          *  数字小（test_11先执行）<数字大（test_22后执行） 
>          *  字母小（test_aa先执行） 比字母大（test_bb后执行）
>          *   数字比字母先执行
>      * **测试套件指定**
>          * 测试套件定义：
>              *  定义：测试用例的集合
>              *  变量名 = unittest.TestSuite()
>          * 添加测试用例进入套件：
>              *  addTest(测试类名字("测试用例函数的名字"))
>              *  用例的添加顺序就是之后用例的执行顺序
>          * 执行测试套件，生成结果
>              *  定义执行器（运行器），例子：
>              *  jwrunner=unittest.TextTestRunner()
>              *  jwrunner.run(jwsuite)
>  * **多用例执行**
>      * 方案1---测试套件指定
>          *  优点：可以选择一部分先执行
>          *  缺点：繁琐
>          *  测试套件定义：
>              *  定义：测试用例的集合
>              *  变量名（jwsuite） = unittest.TestSuite()
>          *  添加测试用例进入套件：
>              *  addTest(测试文件名.测试类名字("测试用例函数的名字"))
>                      *  或者导入
>              *  用例的添加顺序就是之后用例的执行顺序
>          *  执行测试套件，生成结果
>              *  定义执行器（运行器），例子：
>              *  jwrunner=unittest.TextTestRunner()
>              *  jwrunner.run(jwsuite)
>      * 方案2：---使用discover 逐个自动识别用例文件下的内容到测试套中执行
>          *  例子：
>          *  
						
>          *  用处：
>              *  把不同的测试功能单独放到一个文件中
>              *  使用discover() 通过通配符*匹配所以符合的文件名，并执行里面的测试用例
>  * **生成测试报告**
>      * 本质是换一个测试用例执行器
>      * HTMLRunner是一款比较流行的测试报告插件
>          *  将HTMLTestRunner放到项目包下
>          *  插件使用模板
>          *  
>  * **测试装饰器**
>      * 装饰器：本质上是一种python函数，用来修饰其他函数，在不影响其他函数的基础上提供额外的功能。
>      * @ + 装饰语句，放在函数上一行
>      * 第一种：
>          *  unittest.skip(原因):
>              *  无条件的跳过该测试用例，说明跳过测试的原因
>          *  unittest.skipIf(条件,原因):
>              *  如果条件成立，则跳过该测试用例
>          *  unittest.expectedFailure():
>              *  不管执行结果是否失败，该测试用例都标记为失败
>      * 第二种：
>          *  @classmethod 和 setUpclass(cls) 所有用例开始之前准备工作
>          *  @classmethod和tearDownClass(cls) 所有用例结束之后的工作
>      * 一些问题：
>          * 代码和被测代码不在一个目录：
>              *  报错：ModuleNotFoundError: no module named 'xxx'
>              *  注意目录结构 
>              *  被报错语句：
>                  *  from pythonLearn.PyTask import count
>              *  使用from sys import path
>              *  path.append(地址)
>              *  添加找包的地址
>              *  因为是在当前地址下寻找目录的起点，所以地址要添加到导入语句中目录的更上一级
>              *  ..上一级
>                  *  ../.. 上两级
>          * python版本问题
>              * linux下，python有2，3版本区分，所以要使用python3 文件名.py
>              * windows 下使用python 文件名.py即可


