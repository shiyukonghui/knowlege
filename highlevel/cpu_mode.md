># CPU模式
> 
>## 实模式
>### 寄存器(每个都是16位,2 ^ 16 =  65536 ):
>* 通用寄存器 , 里面可以存放数据地址参与计算。
>      * AX , BX , CX , DX , DI , SI , BP
>* 程序指针寄存器 , 始终指向下一条指令的地址(管理程序指令执行)
>   * IP
>* 栈指针寄存器 , 始终指向当前栈顶(管理程序数据)
>   * SP
>* 段寄存器 ,  里面存放一个内存段的基地址。
>   * CS, DS, ES, SS
>* CPU标志寄存器 , 里面存放CPU执行运算指令产生的状态位。
>   * FLAGS
>* 分段内存管理模型:
>   * 读取程序指令:
>      *  CS段寄存器-->CS左移4位  + IP寄存器 = 访问内存的地址。
>   * 读取内存数据:
>      *  DS, ES ,SS 段寄存器 --->左移4位 + AX, BX,CX ,DX ,DI,SI,BP ,SP寄存器 = 访问内存地址
>* 中断:
>   * 中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。
>      *  在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器
>      *  中断如何产生:
>         *  第一种情况是，中断控制器给 CPU 发送了一个电子信号，CPU 会对这个信号作出应答。随后中断控制器会将中断号发送给 CPU，这是硬件中断。
>         *  第二种情况就是 CPU 执行了 INT 指令，这个指令后面会跟随一个常数，这个常数即是软中断号。这种情况是软件中断。
>   * 示例:
>
>* <img src="/img/mem_1.png"/>
>
>* 实模式程序示例:
>*      data SEGMENT ;定义一个数据段存放Hello World!
>*      hello  DB 'Hello World!$' ;注意要以$结束
>*      data ENDS
>*      code SEGMENT ;定义一个代码段存放程序指令
>*      ASSUME CS:CODE,DS:DATA ;告诉汇编程序，DS指向数据段，CS指向代码段
>*      start:
>*      MOV AX,data  ;将data段首地址赋值给AX                
>*      MOV DS,AX    ;将AX赋值给DS，使DS指向data段
>*      LEA DX,hello ;使DX指向hello首地址
>*      MOV AH,09h   ;给AH设置参数09H，AH是AX高8位，AL是AX低8位，其它类似
>*      INT 21h      ;执行DOS中断输出DS指向的DX指向的字符串hello
>*      MOV AX,4C00h ;给AX设置参数4C00h
>*      INT 21h      ;调用4C00h号功能，结束程序
>*      code ENDS
>*      END start
			
>* LEA 是取地址指令，MOV 是数据传输指令， INT 中断
>
>## 保护模式(32位):
>* 提出原因:
>   * 1. 提高寻址能力到32位
>   * 2. 对CPU的指令执行和内存访问进行限制(保护)
>
>###  新的寄存器(32位,可单独使用低16位  , 这个低16位可以进一步分解为8位)
>* 32位通用寄存器:( 里面可以存放数据 , 地址参与计算 )
>   * EAX , EBX , ECX , EDX , EDI , ESI , EBP
>* 32位程序指针寄存器, 始终指向下一条指令的地址(管理程序指令执行)
>   * EIP
>* 栈指针寄存器, 始终指向当前栈顶(管理程序数据)
>   * ESP
>* 16位段寄存器,里面存放一个内存段的基地址。
>   * CS , DS , ES , SS , FS , GS
>* 32位CPU标志寄存器, 里面存放CPU执行运算指令产生的状态位。
>   * EFLAGS
>* 32位CPU控制寄存器(控制CPU的功能特性,如开启保护模式)
>   * CR0 , CR1 , CR2 , CR3
>
>### CPU特权级
>   * 为了区分哪些指令（如 in、out、cli）和哪些资源（如寄存器、I/O 端口、内存地址）可以被访问，CPU 实现了特权级。
>   * 特权级分为 4 级，R0~R3，每个特权级执行指令的数量不同，R0 可以执行所有指令，R1、R2、R3 依次递减，它们只能执行上一级指令数量的子集。
>   * 而内存的访问则是靠后面所说的段描述符和特权级相互配合去实现的
>* 保护模式平坦模型
>   * 用处 : 跳过内存分段模式,使用分页模式
>
>## 长模式:(AMD64)
>### 寄存器
>* 64位通用寄存器:( 里面可以存放数据 , 地址参与计算 )
>     * RAX , RBX , RCX , RDX , RDI , RSI , RBP , R8~R15
>* 64位程序指针寄存器 ,  始终指向下一条指令的地址(管理程序指令执行)
>   *  RIP
>* 栈指针寄存器   , 始终指向当前栈顶(管理程序数据)
>   *  RSP
>* 16位段寄存器  ,  里面存放一个内存段的基地址。
>   *  CS , DS , ES , SS , FS , GS
>* 64位CPU标志寄存器, 里面存放CPU执行运算指令产生的状态位。
>   *  RFLAGS
>* 64位CPU控制寄存器(控制CPU的功能特性,如开启保护模式)
>   * CR0 (32位), CR1 , CR2 , CR3 , CR4
>
>### 切换进入长模式
>* 可以从实模式直接切换到长模式，也可以从保护模式切换长模式
>* 切换示例:
>   * 第一步，准备长模式全局段描述符表
>      *  ex64_GDT:
>      *  null_dsc:  dq 0
>      *  ;第一个段描述符CPU硬件规定必须为0
>      *  c64_dsc:dq 0x0020980000000000  ;64位代码段
>      *  d64_dsc:dq 0x0000920000000000  ;64位数据段
>      *  eGdtLen   equ $ - null_dsc  ;GDT长度
>      *  eGdtPtr:dw eGdtLen - 1  ;GDT界限
>      *       dq ex64_GDT
>   * 第二步,，准备长模式下的 MMU 页表，这个是为了开启分页模式，切换到长模式必须要开启分页，想想看，长模式下已经不对段基址和段长度进行检查了，那么内存地址空间就得不到保护了,长模式下内存地址空间的保护交给了 MMU，MMU 依赖页表对地址进行转换，页表有特定的格式存放在内存中，其地址由 CPU 的 CR3 寄存器指向
>      *  mov eax, cr4
>      *  bts eax, 5   ;CR4.PAE = 1
>      *  mov cr4, eax ;开启 PAE
>      *  mov eax, PAGE_TLB_BADR ;页表物理地址
>      *  mov cr3, eax
>   * 加载 GDTR 寄存器，使之指向全局段描述表：
>      *  lgdt [eGdtPtr]
>   * 开启长模式，要同时开启保护模式和分页模式，在实现长模式时定义了 MSR 寄存器，需要用专用的指令 rdmsr、wrmsr 进行读写，IA32_EFER 寄存器的地址为 0xC0000080，它的第 8 位决定了是否开启长模式。
>      *  ;开启 64位长模式
>      *  mov ecx, IA32_EFER
>      *  rdmsr
>      *  bts eax, 8  ;IA32_EFER.LME =1
>      *  wrmsr
>      *  ;开启 保护模式和分页模式
>      *  mov eax, cr0
>      *  bts eax, 0    ;CR0.PE =1
>      *  bts eax, 31
>      *  mov cr0, eax 
>   * 进行跳转，加载 CS 段寄存器，刷新其影子寄存器
>      *  jmp 08:entry64 ;entry64为程序标号即64位偏移地址
					

 